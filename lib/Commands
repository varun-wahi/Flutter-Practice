                                                        TEXT AND TEXT-STYLE
child: Container(
            height: 100,
            width: 100,
            color: Colors.green,

            child: Center(child: Text("Hello",
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 25,
                  fontWeight: FontWeight.bold,
                  //backgroundColor: Colors.green

                )
            )
            ),
          ),
      ),


      ////////////////////////////////////////////////////  Buttons //////////////////////////////////////////////
      TextButton, Elevated Button, Outlined Button
      TextButton(
              //   child: Text("hello"),
              //   onPressed: (){
              //     print('Text Button Pressed!');
              //   },
              //   onLongPress: (){
              //     print("Long pressed");
              //   }
              // )
      ///////////////////////////////////////////////// IMAGE   ////////////////////////////////////////
      Container(
                  child: Image.asset('assets/images/orange (2).jpg'),
                  width: 200,
                  height: 200,
                 )


      ///////////////////////////////////////////////// ROWS AND COLUMNS   ////////////////////////////////////////
                 Container(
                         width: 500,
                         child: Column(
                           mainAxisAlignment: MainAxisAlignment.spaceAround, //vertical alignment
                           crossAxisAlignment: CrossAxisAlignment.center,
                           children: [
                             Text('1', style: TextStyle(fontSize: 25),),
                             Text('2', style: TextStyle(fontSize: 25),),
                             Text('3', style: TextStyle(fontSize: 25),),
                             ElevatedButton(
                               onPressed: (){
                                 print("hello");
                               },
                               child:const Text("press me"),
                             ),

                           ],
                         ),
                       )
      ///////////////////////////////////////////////// INKWELL   ////////////////////////////////////////

      - INKWELL OFFERS features like onPressed, long press, on double press, etc.
      - This can be used on widgets to add these features to them
      - Widget will be the child of inkwell widget

       body:Center(
              child: InkWell( //onTap, onLongPress, onDoubleTap,
                onTap: (){
                  print("Container Tapped");
                },
                onLongPress: (){
                  print("Container Long Pressed");
                },
                child: Container(
                  width: 200,
                  height: 200,
                  color: Colors.black12,
                  child:  Center(
                      child: InkWell(
                          onTap:(){
                            print("text tapped");
                          } ,
                          child: Text("press me", style: TextStyle(fontSize: 50),)
                      )
                  ),
                ),
              ),
            )

      ///////////////////////////////////////////////// SCROLL-VIEW   ////////////////////////////////////////
Padding(
        padding: const EdgeInsets.all(8.0),
        child: SingleChildScrollView(
          child: Column(
            children: [
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children: [
                      Container(
                        margin: const EdgeInsets.only(right: 10),
                        height: 200,
                        width: 200,
                        color: Colors.green,

                          ),
                      Container(
                        height: 200,
                        width: 200,
                        margin: const EdgeInsets.only(right: 10),
                        color: Colors.red,

                      ),
                      Container(
                        margin: const EdgeInsets.only(right: 10),
                        height: 200,
                        width: 200,
                        color: Colors.yellow,

                      ),
                      Container(
                        margin: const EdgeInsets.only(right: 10),
                        height: 200,
                        width: 200,
                        color: Colors.blue,

                      ),
                    ],
                  ),
                ),
              ),
              Container(
                margin: const EdgeInsets.only(bottom: 10),
                height: 200,

                color: Colors.yellowAccent,

              ),
              Container(
                margin: const EdgeInsets.only(bottom: 10),
                height: 200,

                color: Colors.red,

              ),
              Container(
                margin: const EdgeInsets.only(bottom: 10),
                height: 200,

                color: Colors.blue,

              ),
              Container(
                margin: const EdgeInsets.only(bottom: 10),
                height: 200,

                color: Colors.green,

              ),
              Container(
                margin: const EdgeInsets.only(bottom: 10),
                height: 200,
                color: Colors.yellowAccent,

              ),
            ],
          ),
        ),
      )


      ///////////////////////////////////////////////// LIST-VIEW OR LIST VIEW BUILDER  ////////////////////////////////////////
      - List of similar widgets with different content in a linear way
      - like contacts
      -List view builder is used for making dynamic list (where no of contents in list is not specified)
      - In Builder, one item of list is defined with array of contents, and all items will be similar

      ListView(
              scrollDirection: Axis.vertical,
              reverse: false,
              children: [
                Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: Container(
                    height: 200,
                    width: 200,
                    color: Colors.yellow,
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: Container(
                    height: 200,
                    width: 200,
                    color: Colors.green,
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: Container(
                    height: 200,
                    width: 200,
                    color: Colors.blue,
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: Container(
                    height: 200,
                    width: 200,
                    color: Colors.red,
                  ),
                ),
              ],
            )


//NOW LIST VIEW BUILDER
//List names and colors given

ListView.builder(itemBuilder: (context, index){
        return Padding(
          padding: const EdgeInsets.all(8.0),
          child: Container(
            width: 200,
            height: 200,
            color: colors[index],
            child: Center(
              child: Text(names[index], style: TextStyle(fontSize: 30, fontWeight: FontWeight.bold),),
            ),
          ),
        );
      },
      itemCount: names.length,
      )

//NOW LIST VIEW SEPERATED

ListView.separated(itemBuilder: (context, index){
        return Padding(
          padding: const EdgeInsets.all(8.0),
          child: Container(
            width: 200,
            height: 200,
            color: colors[index],
            child: Center(
              child: Text(names[index], style: TextStyle(fontSize: 30, fontWeight: FontWeight.bold),),
            ),
          ),
        );
      },
        itemCount: names.length,
        separatorBuilder: (context, index){
          return Divider(height: 4, thickness: 3,);
        },
      )
/////////////////////////// STEP BY STEP IMPLEMENTATION //////////////////////////////////
1.   Call main function:

    void main(){
      runApp(PractoApp());
    }

2.  - Create App class inhereting from stateless widget:
    - Return Material app or Cupertino App according to needs and requirements
    - Material app will have TITLE and THEME data, and mainly HOME for homepage

        class PractoApp extends StatelessWidget {
          @override
          Widget build(BuildContext context) {
            return MaterialApp(
              title: "Practo App",
              theme: ThemeData(
                primarySwatch: Colors.indigo
              ),
              home: DashBoardScreen(),
            );
          }

      }

3.  - Create a HomePage class and name it whatever you want (such as DashBoardScreen)
    - In Material App, to create a page Scaffold Widget is used.
    - Scaffold widget contains appBar, body mainly

        class DashBoardScreen extends StatelessWidget{
          @override
          Widget build(BuildContext context) {
            return Scaffold(
              appBar: AppBar(
                title: Center(child: Text("Practo")),
              ),
              body: Center(
                child: Container(
                  color: Colors.red,
                  width: 300,
                  height: 300,
                ),
              ),
            );
          }


///////////////////////////////////////////////// CONTAINER DECORATION  ////////////////////////////////////////

Container(
        color: Colors.white,
        width: double.infinity, //takes full space of screen
        height: double.infinity,

        child: Center(
          child: Container(
            height: 200,
            width: 200,
            //color: Colors.lightGreen,
            //decoration to decorate box further
            //remove color parameter from container when using decoration
            decoration: BoxDecoration(
              color: Colors.blue,

              borderRadius: BorderRadius.circular(22),
                // BorderRadius.only(topLeft: Radius.circular(22),bottomRight: Radius.circular(22)),
                //BorderRadius.circle is better alternative to BR.all
                //Border radius offers all, circular,only for one corner
                //In only, we have to use Radius class in order to provide radius instead of
                //directly providing a double value for radius

              border: Border.all(
                color: Colors.black,
                width: 1,
              ),

              boxShadow: [BoxShadow(
                blurRadius: 3,
                color: Colors.grey,
                //spreadRadius: 3,
              ),
              ],

              //shape: BoxShape.circle // .rectangle by default



            ),
          ),
        ),
      ),
      ///////////////////////////////////////////////// EXPANDED WIDGET  ////////////////////////////////////////

        - Used when in a row column division, we need to divide widgets in a ratio
        - flex parameter can be used to define ration between all expanded widgets in a row or column
        instead of equally dividing between all expanded widgets
        - flex by default is set to 1
        - works on main axis by default according to whether row or column is being used

            Column( //OR ROW
                    // mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Container(
                        // width: 50,
                        height: 100,
                        color: Colors.blue,
                        ) ,

                      Expanded(
                        flex: 1,
                        child: Container(
                          // width: 50,
                          height: 100,
                          color: Colors.orange,

                          ) ,
                        ),

                      Expanded(
                        flex: 2,
                        child: Container(
                          // width: 50,
                          height: 100,
                          color: Colors.yellow,

                          ) ,
                        ),

                      Container(
                        // width: 50,
                        height: 100,
                        color: Colors.red,

                        ) ,
                    ],
                  )

      ///////////////////////////////////////////////// MARGIN PADDING  ////////////////////////////////////////
      - Margin is to distinguish b/w different widgets
      - Padding is reqd. when widget within a widget needs to be distinguished

        Padding(
                padding: const EdgeInsets.all(3.5), //EdgeInsets only used for one side
                child: Column( //OR ROW
                  // mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Container(
                      margin: EdgeInsets.only(bottom: 5),
                      // width: 50,
                      height: 100,
                      color: Colors.blue,
                      ) ,

                    Expanded(
                      flex: 1,
                      child: Container(
                        margin: EdgeInsets.only(bottom: 5),
                        // width: 50,
                        height: 100,
                        color: Colors.orange,

                        ) ,
                      ),

                    Expanded(
                      flex: 2,
                      child: Container(
                        margin: EdgeInsets.only(bottom: 5),
                        // width: 50,
                        height: 100,
                        color: Colors.yellow,

                        ) ,
                      ),

                    Container(
                      // width: 50,
                      height: 100,
                      color: Colors.red,

                      ) ,
                  ],
                ),
              )

      ///////////////////////////////////////////////// LIST TILE AND BUILDER  ////////////////////////////////////////

        ListView.separated(itemBuilder: (context, index){
                return ListTile(
                  leading: Text('${index+1}'),
                  title: Text(names[index]+ " (title)"),
                  subtitle: Text('Number (subtitle)'),
                  trailing: Icon(Icons.add),
                );

              },
              itemCount: names.length,
                separatorBuilder: (context, index){
                return Divider(height: 20,thickness: 1,);
                },
              )

 ///////////////////////////////////////////////// PRACTICE LIST APP  ////////////////////////////////////////

    Widget build(BuildContext context) {

        var names= ['varun','arun', 'tarun', 'charun', 'karun', 'jarun', 'tarun', 'tarun'];
        var colors = [Colors.red, Colors.blue, Colors.yellow, Colors.green, Colors.orange, Colors.pinkAccent, Colors.amber, Colors.cyan];

        return Scaffold(
          appBar: AppBar(
            title: Center(child: const Text("Practo")),
          ),
          body:
            ListView.builder(itemBuilder: (context, index){
              return Padding(
                padding: const EdgeInsets.all(3.0),
                child: Center(
                  child: InkWell(

                    onTap: (){
                      print("Hello Index: $index");
                    },
                    child: Container(
                      height: 100,
                      width: double.infinity,

                      child: Center(child: Text(names[index], style: TextStyle(fontWeight: FontWeight.bold, fontSize: 25, color: Colors.white))),
                      decoration: BoxDecoration(
                      color: colors[index],
                      borderRadius: BorderRadius.circular(10),
                    ),
                    ),
                  ),
                ),
              );
            },
            itemCount: names.length,
            )
        );
      }


 ///////////////////////////////////////////////// CIRCLE AVATAR  ////////////////////////////////////////
    -   Making a contact list using flutter

        ListView.separated(itemBuilder: (context, index){
                  return ListTile(
                    leading: CircleAvatar(
                      // child: Text('$index'),
                      maxRadius: 20,
                      backgroundImage: AssetImage('assets/images/contact_avatar.png'),
                      backgroundColor: colors[index],

                    ),
                    title: Text('${names[index]}'),
                    subtitle: Text('${index+1}'*10),

                    trailing: Icon(Icons.add),
                  );
                },
                    separatorBuilder: (context, index){
                      return Divider(height: 5,thickness: 4,);
                    },
                    itemCount: names.length)

 ///////////////////////////////////////////////// FONT STYLE  ////////////////////////////////////////
    - Download fonts from google fonts
    - Make a directory in assets folder named fonts and place .ttf files
    - Go to the pubspec.yaml file and add font family to the file
    - press pub get button to update file
    - use this font using style in Text


    1. In ThemeData define different styles as such;

        theme: ThemeData(
                primarySwatch: Colors.indigo,
                textTheme: TextTheme(
                  headline1: TextStyle(fontSize:50, fontWeight: FontWeight.bold,),
                  subtitle1: TextStyle(fontSize:20, fontWeight: FontWeight.normal,color: Colors.grey, fontStyle: FontStyle.italic,),
                ),
                fontFamily: 'Roboto',

              ),


    2. Then in Text Widgets, you can use these pre-defined styles as follows

    Column(
              children: [
                Center(
                    child: Text(
                        "Headline1 text testing",
                        style:Theme.of(context).textTheme.headline1
                    )
                ),

                Center(
                    child: Text(
                        "Subtitle 1 testing",
                        style:Theme.of(context).textTheme.subtitle1
                    )
                ),
              ],
            )

    3. In order to extend a style, we can us copyWith() function.
       All other attributes will be copied

            Text(
                "Subtitle 1 testing",
                style:Theme.of(context).textTheme.subtitle1!.copyWith(color: Colors.red)
                )

    4. - Now these headline1, headline2, etc are only limited no of themes for text
       - So the best solution is to create a new directory named "ui_helper" in "lib" folder
       - Create a new dart file called "util.dart" or anything

            import 'dart:ui';
            import 'package:flutter/material.dart';

            TextStyle TextStyle1(){
              return TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.bold,
                color: Colors.grey
                //blah blah other attributes
              );
            }

            TextStyle TextStyle2(){
              return TextStyle(
                  fontSize: 21,
                  fontWeight: FontWeight.bold,
                  color: Colors.grey
                //blah blah other attributes
              );
            }

            TextStyle TextStyle3(){
              return TextStyle(
                  fontSize: 11,
                  fontWeight: FontWeight.bold,
                  color: Colors.grey
                //blah blah other attributes
              );
            }

            TextStyle TextStyle4(){
              return TextStyle(
                  fontSize: 11,
                  fontWeight: FontWeight.bold,
                  color: Colors.grey
                //blah blah other attributes
              );
            }

 5. Import util package in main.dart file

        import lib/ui_helper/util.dart

        Text(
                          "Util package testing",
                          style:TextStyle1()
                      ),

 6. For further customisation in fonts styles in utils.dart add inside{} inside parameter of the funciton]\

        TextStyle TextStyle1({
          Color textColor = Colors.black,
          FontWeight fontWeight = FontWeight.normal
        })
        {
          return TextStyle(
            fontSize: 11,
            fontWeight: FontWeight.bold,
            color: Colors.grey
            //blah blah other attributes
          );
        }


///////////////////////////////////////////////// CARD WIDGET  ////////////////////////////////////////

    - Elevated cards with shadows underneath
    - Looks more stylish
    - Such as in Contact List

        Card(
                  shadowColor: Colors.pinkAccent,
                  elevation: 5,
                    child: Padding(
                      padding: const EdgeInsets.all(8.0),
                      child: Text("Text", style: TextStyle1(),),
                    ),
                ),

///////////////////////////////////////////////// USER INPUT  ////////////////////////////////////////

1. Define TextControllers as global first these will take and store input from text fields

    var emailText = TextEditingController();
    var passText = TextEditingController();

2. Important properties of TextField are enabled, controller, and decoration(inputDecoration -> focused, enabled,disabled)


    Center(
        child: Container(
          width: 300,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center, //used for center alignment of list
            children: [

              TextField(
                keyboardType: TextInputType.emailAddress, //Define type of entry
                enabled: true,
                controller: emailText, //TextEditingController emailText made as global above

                decoration: InputDecoration(

                  hintText: "E-Mail",
                    focusedBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(21),
                        borderSide: BorderSide(
                            color: Colors.deepOrange,
                          width: 2
                        )
                    ),
                    enabledBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(21),
                      borderSide: BorderSide(
                        color: Colors.deepPurple,
                        width: 2
                      )

                    ),
                    disabledBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(21),
                        borderSide: BorderSide(
                            color: Colors.grey,
                            width: 2
                        )

                    ),

                    // suffixText: "Username",
                    suffixIcon: IconButton(onPressed: ()
                    {
                      print("Email button pressed.");

                      },
                        icon: Icon(Icons.remove_red_eye, color: Colors.deepPurple,
                        )
                    ),


                  
                ),
              ),


              Container(
                height: 11,
              ),


              TextField(
                enabled: true,
                controller: passText,
                obscureText: true, //hide text
                keyboardType: TextInputType.visiblePassword,  //To hide password input
                
                decoration: InputDecoration(
                    hintText: "Password",
                    focusedBorder: OutlineInputBorder(  //when textbox is selected
                        borderRadius: BorderRadius.circular(21),
                        borderSide: BorderSide(
                            color: Colors.deepOrange,
                            width: 2
                        )
                    ),
                    enabledBorder: OutlineInputBorder(   //when textbox is enabled
                        borderRadius: BorderRadius.circular(21),
                        borderSide: BorderSide(
                            color: Colors.deepPurple,
                            width: 2
                        )

                    ),
                    disabledBorder: OutlineInputBorder( //when textbox is disabled
                        borderRadius: BorderRadius.circular(21),
                        borderSide: BorderSide(
                            color: Colors.grey,
                            width: 2
                        )

                    ),

                    // suffixText: "Password",


                    border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(21),
                        borderSide: BorderSide(
                            color: Colors.deepOrange
                        )
                    )
                ),
              ),

              Container(
                height: 11,
              ),
              
              ElevatedButton(onPressed: (){
                String uEmail = emailText.text; //taking input from text fields and storing it
                String uPass = passText.text;
                print("Email: ${emailText.text}");
                print("Password: ${passText.text}");

              }, child: Text("Login"))


            ],
          ),
        )
      ),



//////////////////////////////////////////////// GRID VIEW  ////////////////////////////////////////
   
1. It is automatically scrollable
2. Mainly three types:
    - GridView.count
    - GridView.extent
    - GridView.builder


* GridView.count

    Padding(
            padding: const EdgeInsets.all(13.0),
            child: GridView.count(
              //crossAxisCount, children are main properties
              crossAxisCount: 3, //No. of columns
              crossAxisSpacing: 13, //Space between Columns
              mainAxisSpacing: 13,  //Space between Rows

              children: [
                Container(
                  color: colors[0],
                ),
                Container(
                  color: colors[1],
                ),
                Container(
                  color: colors[2],
                ),
                Container(
                  color: colors[3],
                ),
                Container(
                  color: colors[4],
                ),
              ],
            ),
          ),

3. You can also use GridView.extent when you dont want to define
a specific no of columns for each row and instead you want to
define maximum width of widget.
    
    Padding(
          padding: const EdgeInsets.all(13.0),
          child: GridView.extent(
            maxCrossAxisExtent: 500,
            crossAxisSpacing: 13, //Space between Columns
            mainAxisSpacing: 13,
            children: [
              Container(
                color: colors[0],
              ),
              Container(
                color: colors[1],
              ),
              Container(
                color: colors[2],
              ),
              Container(
                color: colors[3],
              ),
              Container(
                color: colors[4],
              ),
            ],
          )),

4. You can also use GridView.builder when you need dynamic list of elements 
of similar type

    GridView.builder(
          itemCount: colors.length,
          gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
            maxCrossAxisExtent: 300,
            crossAxisSpacing: 10,
            mainAxisSpacing: 10,
          ),
          //OR YOU CAN USE SilverGridDelegateWithMaxCrossCount()
          itemBuilder: (context, index) {
            //press ctrl+space for automatic syntax
            return Container(
              color: colors[index],
            );
          },
        ),


//////////////////////////////////////////////// CALLBACK FUNXNS  /////////////////////////////////////
   
///Whenever we need to reuse the function somewhere or instead of
///defining onPressed function for multiple buttons again and again,
///we can globally define a funtion in that class and pass it as argument
///in widget
///For Example:
   
   void callback() {
    print("Clicked");
  }

///This function can now be used directly as an argument in mutiple places
   
   ElevatedButton(
            child: Text("Click"),
            
            //Instead of defining funtion like this
            // onPressed: () {
            //   print("Clicked");
            // },

            onPressed: callback,
          ),

//////////////////////////////////////////////// CUSTOM WIDGET  /////////////////////////////////////      
///It is used mainly in order to reduce redundancy
///For example, if we are going to use the same kind of decorated
///container in our app again and again, we will just define a 
///custom widget for it and then use it.
/// It is highly recommended to use as many custom widgets in 
/// your app as it helps reduce redundancy a lot and can save a 
/// lot of time, even when updating
/// It also increases readability
/// 
/// 1. Create a custom widget and make a seperate class for it:
   
    class InstagramStoryScrollView extends StatelessWidget {
      
      @override
      Widget build(BuildContext context) {
        return Expanded(
          flex: 1,
          child: Container(
            color: Colors.deepPurple,
            child: ListView.builder(
              //padding: EdgeInsets.all(8),
              scrollDirection: Axis.horizontal,
              itemBuilder: (context, index) {
                return Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: SizedBox(
                    width: 70,
                    child: CircleAvatar(
                      child: Text("$index"),
                      maxRadius: 50,
                      backgroundColor: Colors.white,
                    ),
                  ),
                );
              },
              itemCount: DashBoardScreen().colors.length,
            ),
          ),
        );
      }
    }
    class ContactsListView extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Expanded(
      flex: 4,
      child: Container(
        color: DashBoardScreen().colors[1],
        child: ListView.builder(
          //padding: EdgeInsets.all(8),
          scrollDirection: Axis.vertical,
          itemBuilder: (context, index) {
            return Padding(
              padding: const EdgeInsets.all(8.0),
              child: ListTile(
                leading: CircleAvatar(
                  child: Text("$index"),
                  maxRadius: 50,
                  backgroundColor: Colors.white,
                ),
                title: Text("Hello " + "$index"),
                trailing: IconButton(
                    icon: Icon(Icons.delete),
                    onPressed: DashBoardScreen().callback),
              ),
            );
          },
          itemCount: DashBoardScreen().colors.length,
        ),
      ),
    );
  }
}

class CardGridView extends StatelessWidget {
  @override
  Widget build(Object context) {
    return Expanded(
      flex: 2,
      child: Container(
        color: Colors.white,
        child: GridView.builder(
          gridDelegate:
              SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3),
          itemBuilder: (context, index) {
            return Padding(
              padding: EdgeInsets.all(8),
              child: Container(
                decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(11),
                    color: DashBoardScreen().colors[index]),
              ),
            );
          },
          itemCount: DashBoardScreen().colors.length,
        ),
      ),
    );
  }
}

/// 2. Use the class directly in the screen that you want to use it on
   
   body: Center(
            child: Column(
      children: [
        InstagramStoryScrollView(),
        ContactsListView(),
        CardGridView(),
      ],
    ))

//////////////////////////////////////////////// STACK WIDGET  /////////////////////////////////////    
///Stack is used for overlapping multiple widgets
///First widget in stack stays lowest position
///First widget should be bigger in size than 
///For example: Having text and an image, overlaid
/// with a gradient abd a button attached to the bottom
///Stack has children property for sub-widgets
///
   
   Container(
          height: 600,
          width: 600,
          child: Stack(
            children: [
              Container(
                height: 300,
                width: 300,
                decoration: BoxDecoration(
                    color: Colors.amber,
                    borderRadius: BorderRadius.circular(21)),
              ),
              Positioned(
                left: 70,
                top: 70,
                child: Container(
                  height: 250,
                  width: 250,
                  decoration: BoxDecoration(
                      color: Color.fromARGB(255, 2, 186, 24),
                      borderRadius: BorderRadius.circular(21)),
                ),
              ),
              Positioned(
                left: 130,
                top: 130,
                child: Container(
                  height: 200,
                  width: 200,
                  decoration: BoxDecoration(
                      color: Colors.red,
                      borderRadius: BorderRadius.circular(21)),
                ),
              ),
              Positioned(
                left: 170,
                top: 170,
                child: Container(
                  height: 150,
                  width: 150,
                  margin: EdgeInsets.only(left: 20, top: 20),
                  decoration: BoxDecoration(
                      color: Colors.blue,
                      borderRadius: BorderRadius.circular(21)),
                ),
              )
            ],
          ),
        )


//////////////////////////////////////////////// CUSTOM WIDGET ////////////////////////////////////////////////
///A custom widget can be defined and used all over the application
///again and again
///It is useful to reduce code redundancy and helps with readability
///We can define a custom style for a widget
///1. Create a folder called 'widgets' under lib folder
///2. Make a dart file named 'blah_blah_widget.dart'
///3. In that dart file, define the widget class extending
///   from Stateless or Stateful class
///4. Create a constructor defining all he properties of Widget
///5. For example we have defined constructor for RoundedButton as follows:
  class RoundedButton extends StatelessWidget {
    final String btnName;
    final Icon? icon;   //The '?' says that value can be null
    final Color bgColor;
    final TextStyle? textStyle;
    final VoidCallback? callBack; //Void call back funtion is a funtion which does not
                                  //take any arguments and returns void

    RoundedButton(
        {required this.btnName,           //required keyword defines that parameter is necesarry for user to input
        this.bgColor = Colors.deepPurple, //default value provided
        this.callBack,
        this.icon,
        this.textStyle}) {
      print("hello");
    }
  }

///6. Define your custom widget using all the properties
///Here we have defined a rounded rectangular button which can take a text input,icon, bgColor, textStyle, etc
///If icon gets passed as an argument, it will use icon and text both, else only text
  
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Container(
        width: 120,
        child: ElevatedButton(
          onPressed: () {
            callBack!(); //The '!' mark says that callBack will NOT be null
          },
          child: icon != null
              ? Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  //icon!=null means if icon is not null then return Row
                  //or if there is no icon, return only text
                  //if else can also be used directly
                  children: [
                    Text(
                      btnName,
                      style: textStyle,
                    ),
                    SizedBox(width: 11),
                    icon!,
                  ],
                )
              : Text(//The ':' serves as else statement (If icon null, return Text only)
                  btnName,
                  style: textStyle,
                ), 

          style: ElevatedButton.styleFrom(
              primary: bgColor,
              shadowColor: Colors.black,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(21))),
        ),
      ),
    );
  }

//////////////////////////////////////////////// WRAP WIDGET ////////////////////////////////////////////////
///It is used when in a row, items are overflowing, the widgets wrap over to the next line
///These directions can be switched to horizontal also
   
   Container(
          width: double.infinity,
          height: double.infinity,
          child: Wrap(
            spacing: 11,
            runSpacing: 11, //Cross axis spacing
            alignment: WrapAlignment.spaceEvenly,
            //direction: Axis.vertical, //For Column
            //replaced Row with Wrap
            children: [
              Container(
                width: 150,
                height: 200,
                color: colors[0],
              ),
              Container(
                width: 150,
                height: 200,
                color: colors[1],
              ),
              Container(
                width: 150,
                height: 200,
                color: colors[2],
              ),
              Container(
                width: 150,
                height: 200,
                color: colors[3],
              ),
              Container(
                width: 150,
                height: 200,
                color: colors[0],
              ),
            ],
          ),
        )

//////////////////////////////////////////////// SIZED BOX ////////////////////////////////////////////////      
///Sized box is used when child needs a size, and not any style
///such as controlling size of button, margin contraints, rows etc.
///Three types:
///   1. SizedBox.square
///   2. SizedBox.expanded (takes width of parent)
///   3. SizedBox.shrink  (takes min possible dimensions of parent)

   Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              SizedBox(
                width: 150,
                height: 80,
                child: ElevatedButton(
                  onPressed: () {},
                  child: Text("Hello"),
                ),
              ),
              SizedBox(
                height: 10,
              ),
              SizedBox.square(
                dimension: 200,
                child: ElevatedButton(
                  onPressed: () {},
                  child: Text("Not hello"),
                ),
              ),
            ],
          ),
        )

/////////////////////////////////////////////// RICH TEXT ////////////////////////////////////////////////
///Whenever we need to style words of the same sentence differently
///Alternative to using normal text in order to style your app
///text attribute is for default styling
///children attribute will contain different TextSpans with different
///   styles in the same sentence
   Center(
            child: RichText(
                text: TextSpan(
                    style: TextStyle(
                      //Default text style
                      color: Colors.blueGrey,
                      fontSize: 31,
                    ),
                    children: [
              TextSpan(
                text: "hello ",
              ),
              TextSpan(
                text: "World! ",
                style: TextStyle(fontWeight: FontWeight.bold, color: colors[1]),
              ),
              TextSpan(
                text: "Welcome to ",
                style: TextStyle(
                    fontWeight: FontWeight.normal, fontStyle: FontStyle.italic),
              ),
              TextSpan(
                text: "Flutter! ",
                style: TextStyle(fontWeight: FontWeight.bold, color: colors[4]),
              )
            ])))

/////////////////////////////////////////////// ICONS ////////////////////////////////////////////////
/// PNGs can also be used as icons by making a folder in assets
   Center(
            child: Icon(
          Icons.add_a_photo,
          size: 50,
          color: Colors.deepPurple,
        ))

/// More Icons can be availed by using awesome icons   
/// 1. Search font awesome flutter on Google  
/// 2. copy the dependency in pubspec.yaml file
    font_awesome_flutter:  ^10.5.0(latest version)
///3. From the webite copy the import line
    import 'package:font_awesome_flutter/font_awesome_flutter.dart';
///4. Use Icon:   
    FaIcon(size: 50, FontAwesomeIcons.amazon)

/////////////////////////////////////////////// POSITIONED WIDGET ////////////////////////////////////////////////
///Wrapped inside a STACK Widget
  
  Container(
          width: double.infinity,
          height: double.infinity,
          color: colors[8],
          child: Center(
            child: Stack(
              children: [
                Positioned(
                  bottom: 21,
                  right: 21,
                  child: Container(
                    width: 300,
                    height: 300,
                    color: colors[1],
                  ),
                )
              ],
            ),
          ),
        )

/////////////////////////////////////////////// STATEFUL/ STATELESS ////////////////////////////////////////////////        
///To convert a Stateless widget to a Stateful widget, First make a stateless widget
///open context actions and convert it into a stateful widget
///* Make changes to the counter before or inside the setState() function for them to reflect on UI
  
  class DashBoardScreen extends StatefulWidget {
  @override
  State<DashBoardScreen> createState() => _DashBoardScreenState(); 
  //Use createState() Function to call a state class extending State of you class type
}

class _DashBoardScreenState extends State<DashBoardScreen> { //here
  int counter = 0;
  @override
  Widget build(BuildContext context) {//make a normal class with a Scaffold
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              'Counter: $counter',
              style: TextStyle(fontSize: 31),
            ),
            FloatingActionButton(
              onPressed: () {
                setState(() { //here we will increase the counter inside the setState so it shows changes
                  counter++;
                });
              },
              child: Icon(Icons.add),
            )
          ],
        ),
      ),
    );
  }
}

///////////////////////////////SIMPLE CALCULATOR USING STATEFUL WIDGET //////////////////////////////////////////////// 
   

   class CalculatorHome extends StatefulWidget {
  @override
  State<CalculatorHome> createState() => _CalculatorHomeState();
}

class _CalculatorHomeState extends State<CalculatorHome> {
  var textController1 = TextEditingController();
  var textController2 = TextEditingController();

  var answer = 0.00;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.brown[200],
      appBar: AppBar(
        title: Center(child: Text("Calculator")),
      ),
      body: Container(
        color: Colors.white,
        child: Center(
            child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Padding(
              padding: EdgeInsets.all(21),
              child: Text(
                "The result is: ${answer.toStringAsFixed(2)}", //toString.fixed() HELPS IN NO OF DIGITS AFTER DECIMAL
                style: TextStyle(fontSize: 21, fontWeight: FontWeight.bold),
              ),
            ),
            TextField(
              textAlign: TextAlign.center,
              keyboardType: TextInputType.number,
              controller: textController1,
            ),
            SizedBox(
              height: 20,
            ),
            TextField(
              textAlign: TextAlign.center,
              keyboardType: TextInputType.number,
              controller: textController2,
            ),
            SizedBox(
              height: 20,
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                ElevatedButton(
                    onPressed: () {
                      var no1 = double.parse(textController1.text.toString()); //HERE WE PARSE THE VALUES OF TEXT FIELDS
                      //FIRST WE HAVE TO CONVERT TO STRING AND THEN TO INTEGER OR DOUBLE USING DOUBLE.PARSE METHOD
                      var no2 = double.parse(textController2.text.toString());
                      answer = no1 + no2;
                      setState(() {}); //HERE WE RESET STATE
                    },
                    child: Text('Add')),
                ElevatedButton(
                    onPressed: () {
                      var no1 = double.parse(textController1.text.toString());
                      var no2 = double.parse(textController2.text.toString());
                      answer = no1 - no2;
                      setState(() {});
                    },
                    child: Text('Subtract')),
                ElevatedButton(
                    onPressed: () {
                      var no1 = double.parse(textController1.text.toString());
                      var no2 = double.parse(textController2.text.toString());
                      answer = no1 * no2;
                      setState(() {});
                    },
                    child: Text('Multiply')),
                ElevatedButton(
                    onPressed: () {
                      var no1 = double.parse(textController1.text.toString());
                      var no2 = double.parse(textController2.text.toString());
                      answer = no1 / no2;
                      setState(() {});
                    },
                    child: Text('Divide')),
              ],
            )
          ],
        )),
      ),
    );
  }
}



///////////////////////////////Constraint Box //////////////////////////////////////////////// 
///Used in order to define maximum and minimum dimensions of a widget
    Center(
          child: ConstrainedBox(
              constraints:
                  BoxConstraints(minWidth: 200, maxWidth: 700, minHeight: 40),
              child: ElevatedButton(onPressed: () {}, child: Text("Press"))),
        )


////////////////////////////// Switching Screens ////////////////////////////////////////////////
/// 1. In material page, home will be the first page opened
/// 2. To switch screen use:
    ElevatedButton(
          child: Text("Next"),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => MyHomeScreen();
                ),
              );
            },
            
          ),
/// Screen memory management is in stack formation
/// first screen on buttom
/// follows LIFO
/// To delete top page from stack, or go back to previous screen
/// we can use:
    
    ElevatedButton(
          child: Text("Next"),
            onPressed: () {
              Navigator.pop(context);
            },
          ),
    

////////////////////////////// SPLASH SCREEN ////////////////////////////////////////////////
///Show page while loading components in background is when splash
///screen is used
///We have to use State using StatefulWidget in init() stage
///Navigator.pushReplacement will be used
///Using the Timer class, we can automatically change page
///Instead of using timers, we can also call page when api is loaded,
///Or when connection with server is established
   class SplashScreen extends StatefulWidget {
  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> {
  @override
  void initState() {
    super.initState();

    Timer(
      Duration(seconds: 2),
      () {
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (context) => IntroScreen()),
        );
        //push replacement pushes new screen and removes current one
        //from stack
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        color: Colors.deepOrange,
        child: Center(
          child: Text(
            "Practo",
            style: TextStyle(
              fontSize: 70,
              fontStyle: FontStyle.italic,
              color: Colors.white,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }
}